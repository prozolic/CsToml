using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text;

namespace CsToml.Generator;

[Generator(LanguageNames.CSharp)]
public partial class Generator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.AddSource("CsToml.Generator_Annotation.g.cs", """
// <auto-generated> This .cs file is generated by CsToml.Generator. </auto-generated>
#nullable enable

using System;
using System.Diagnostics.CodeAnalysis;
namespace CsToml;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
internal sealed class TomlSerializedObjectAttribute : Attribute
{
    public TomlNamingConvention NamingConvention { get; init; }

    public TomlSerializedObjectAttribute()
    {}
}

[AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
internal sealed class TomlValueOnSerializedAttribute : Attribute
{
    public string? AliasName { get; init; }

    public TomlNullHandling NullHandling { get; init; }

    public TomlValueOnSerializedAttribute()
    {}
}

""");
        });

        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
            "CsToml.TomlSerializedObjectAttribute",
            static (node, token) =>
            {
                return node is ClassDeclarationSyntax or StructDeclarationSyntax or RecordDeclarationSyntax;
            },
            static (context, token) => context).
            Combine(context.CompilationProvider).
            WithComparer(Comparer.Instance);

        context.RegisterSourceOutput(source, Emit);
    }

    private void Emit(SourceProductionContext context, (GeneratorAttributeSyntaxContext, Compilation) source)
    {
        var syntaxContext = source.Item1;
        var symbol = (INamedTypeSymbol)syntaxContext.TargetSymbol;
        var typeNode = (TypeDeclarationSyntax)syntaxContext.TargetNode;

        var typeMeta = new TypeMeta(symbol, typeNode);
        var constructorMeta = new ConstructorMeta(symbol, typeNode, typeMeta);

        if (!(typeMeta.Validate(context) && constructorMeta.Validate(context)))
            return;

        // '<' and '>' are not allowed in file names.
        var replaceTypeName = typeMeta.TypeName.Replace("<", "_").Replace(">", "_").Replace(",", "_").Replace(" ", "");

        context.AddSource($"{replaceTypeName}_generated.g.cs", Generate(typeMeta, constructorMeta));
    }

    private string Generate(TypeMeta typeMeta, ConstructorMeta constructorMeta)
    {
        // Check if it belongs to the global namespace.
        var namespaceTag = string.IsNullOrWhiteSpace(typeMeta.NameSpace) ? string.Empty : $"namespace {typeMeta.NameSpace};";

        var code = $$"""
// <auto-generated> This .cs file is generated by CsToml.Generator. </auto-generated>
#nullable enable
#pragma warning disable CS0219 // The variable 'variable' is assigned but its value is never used
#pragma warning disable CS8600 // Converting null literal or possible null value to non-nullable type.
#pragma warning disable CS8601 // Possible null reference assignment.
#pragma warning disable CS8602 // Dereference of a possibly null reference.
#pragma warning disable CS8603 // Possible null reference return.
#pragma warning disable CS8604 // Possible null reference argument for parameter.
#pragma warning disable CS8619 // Possible null reference assignment fix.
#pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.

using CsToml;
using CsToml.Error;
using CsToml.Formatter;
using CsToml.Formatter.Resolver;

{{namespaceTag}}

partial {{typeMeta.TypeKeyword}} {{typeMeta.TypeName}} : ITomlSerializedObject<{{typeMeta.GenericTypeParameterName}}>
{

    static {{typeMeta.GenericTypeParameterName}} ITomlSerializedObject<{{typeMeta.GenericTypeParameterName}}>.Deserialize(ref TomlDocumentNode rootNode, CsTomlSerializerOptions options)
    {
{{GenerateDeserializePart(typeMeta, constructorMeta)}}    }

    static void ITomlSerializedObject<{{typeMeta.GenericTypeParameterName}}>.Serialize<TBufferWriter>(ref Utf8TomlDocumentWriter<TBufferWriter> writer, {{typeMeta.GenericTypeParameterName}} target, CsTomlSerializerOptions options)
    {
{{GenerateSerializePart(typeMeta)}}    }

    static void ITomlSerializedObjectRegister.Register()
    {
{{GenerateRegisterPart(typeMeta)}}
    }
}
""";

        return code;
    }

    private string GenerateDeserializePart(TypeMeta typeMeta, ConstructorMeta constructorMeta)
    {
        var builder = new StringBuilder();

        if (typeMeta.IsReferenceType)
        {
            builder.AppendLine($$"""
        if (!(rootNode.HasValue || rootNode.IsTableHeader)) return default;

""");
        }

        foreach (var member in typeMeta.OrderedMembers)
        {
            var propertyName = member.DefinedName;
            var accessName = member.CanAliasName ? member.AliasName : propertyName;

            builder.AppendLine($$"""
        var __{{propertyName}}__RootNode = rootNode[{{$"@\"{accessName}\"u8"}}];
        var __{{propertyName}}__ = options.Resolver.GetFormatter<{{member.Symbol.Type.ToFullFormatString()}}>()!.Deserialize(ref __{{propertyName}}__RootNode, options);
""");
        }

        builder.AppendLine();

        if (constructorMeta.IsImplicitlyDeclared || constructorMeta.IsParameterlessOnly || (constructorMeta.ConstructorParameters.Length == 0 && constructorMeta.IncludeParameterless))
        {
            builder.AppendLine($"        var target = new {typeMeta.TypeName}(){{");
            foreach (var member in typeMeta.OrderedMembers)
            {
                var propertyName = member.DefinedName;
                builder.AppendLine($"            {propertyName} = __{propertyName}__,");
            }
            builder.AppendLine($"        }};");
            builder.AppendLine();
            builder.AppendLine($"        return target;");
        }
        else
        {
            builder.Append($"        var target = new {typeMeta.TypeName}(");

            for (var i = 0; i < constructorMeta.ConstructorParameterProperties.Length; i++)
            {
                var p = constructorMeta.ConstructorParameterProperties[i];
                var propertyName = p.Name;
                builder.Append($"__{propertyName}__");
                if (i < constructorMeta.ConstructorParameters.Length - 1)
                {
                    builder.Append(", ");
                }
            }
            builder.Append($")");

            if (constructorMeta.MembersOfObjectInitialisers.Length > 0)
            {
                builder.AppendLine($"{{");
                foreach (var property in constructorMeta.MembersOfObjectInitialisers)
                {
                    var propertyName = property.Name;
                    builder.AppendLine($"            {propertyName} = __{propertyName}__,");
                }
                builder.AppendLine($"        }};");
            }
            else
            {
                builder.AppendLine(";");
            }
            builder.AppendLine($"        return target;");

        }

        return builder.ToString();
    }

    private string GenerateSerializePart(TypeMeta typeMeta)
    {
        var builder = new StringBuilder();

        if (typeMeta.IsReferenceType)
        {
            builder.AppendLine($$"""
        if (target == null) ThrowIfNull(nameof(target));

""");
        }

        // Implement the setting process for each lastValue.        
        GenerateLastValueDeclarations(builder, typeMeta);

        var onlyTomlSerializedObject = typeMeta.OrderedMembers.Length == 1 &&
            typeMeta.OrderedMembers[0].SerializationKind == TomlSerializationKind.TomlSerializedObject;
        if (!onlyTomlSerializedObject)
        {
            builder.AppendLine("        writer.BeginScope();");
        }

        var multipleStyleHashtable = new HashSet<TomlSerializationKind>
        {
            TomlSerializationKind.TomlSerializedObject,
            TomlSerializationKind.TomlSerializedObjectArray,
            TomlSerializationKind.TomlSerializedObjectCollection,
            TomlSerializationKind.Dictionary,
            TomlSerializationKind.TypeParameter,
            TomlSerializationKind.NullableStructWithTypeParameter
        };

        // Check if there are any properties that use header style.
        var existedHeaderStyleType = typeMeta.OrderedMembers.Any(m => multipleStyleHashtable.Contains(m.SerializationKind));
        if (existedHeaderStyleType)
        {
            builder.AppendLine($$"""
        if (options.SerializeOptions.TableStyle != TomlTableStyle.Header && options.SerializeOptions.ArrayStyle == TomlArrayStyle.Header)
        {
""");
            // change order to serialize properties to avoid nested table header style.
            var orderedMembers = typeMeta.OrderedMembers.OrderBy(m =>
            {
                if (m.SerializationKind == TomlSerializationKind.TomlSerializedObjectArray)
                {
                    return TomlSerializationKind.TomlSerializedObjectArrayForHeaderStyle;
                }
                if (m.SerializationKind == TomlSerializationKind.TomlSerializedObjectCollection)
                {
                    return TomlSerializationKind.TomlSerializedObjectCollectionForHeaderStyle;
                }
                return m.SerializationKind;
            }).ToImmutableArray();

            // If orderedMembers differs from typeMeta.OrderedMembers, 
            // the lastValue variables need to be initialized.
            var shouldInitializeVariable = !typeMeta.OrderedMembers.SequenceEqual(orderedMembers);

            GenerateLastValueProcess(builder, orderedMembers, "    ", shouldInitializeVariable);
            GenerateSerializePropertyPart(builder, orderedMembers, rootIndent: "    ", tableStyleHeader: false, arrayStyleHeader: true);
            builder.AppendLine($$"""
        }
""");
            builder.AppendLine($$"""
        else
        {
""");
            GenerateLastValueProcess(builder, typeMeta.OrderedMembers, "    ", false);
            GenerateSerializePropertyPart(builder, typeMeta.OrderedMembers, rootIndent: "    ", tableStyleHeader: false, arrayStyleHeader: false);
            builder.AppendLine($$"""
        }
""");
        }
        else
        {
            GenerateLastValueProcess(builder, typeMeta.OrderedMembers, "", false);
            GenerateSerializePropertyPart(builder, typeMeta.OrderedMembers, rootIndent: "", tableStyleHeader: false, arrayStyleHeader: false);
        }

        if (!onlyTomlSerializedObject)
        {
            builder.AppendLine("        writer.EndScope();");
        }

        if (typeMeta.IsReferenceType)
        {
            builder.AppendLine($$"""

        static void ThrowIfNull(string args)
        {
            throw new CsTomlException($@"Serialization failed because the argument '{args}' is null.");
        }
""");
        }
        return builder.ToString();
    }

    private void GenerateLastValueDeclarations(StringBuilder builder, TypeMeta typeMeta)
    {
        var members = typeMeta.OrderedMembers;
        for (var i = 0; i < members.Length; i++)
        {
            var propertyName = members[i].DefinedName!;
            if (i == members.Length - 1)
            {
                builder.AppendLine($"        var lastValue_{propertyName} = true;");
                builder.AppendLine();
            }
            else
            {
                builder.AppendLine($"        var lastValue_{propertyName} = false;");
            }
        }
    }

    private void GenerateLastValueProcess(StringBuilder builder, ImmutableArray<TomlValueOnSerializedData> members, string rootIndent, bool shouldInitializeVariable)
    {
        if (shouldInitializeVariable)
        {
            for (var i = 0; i < members.Length; i++)
            {
                var propertyName = members[i].DefinedName!;
                if (i == members.Length - 1)
                {
                    builder.AppendLine($"        {rootIndent}lastValue_{propertyName} = true;");
                    builder.AppendLine();

                }
                else
                {
                    builder.AppendLine($"        {rootIndent}lastValue_{propertyName} = false;");
                }
            }
        }

        for (var i = members.Length - 1; i >= 0; i--)
        {
            if (!members[i].IsNullable) break;

            var propertyName = members[i].DefinedName!;
            if (i != 0)
            {
                builder.AppendLine($$"""
        {{rootIndent}}if (lastValue_{{propertyName}} && target.{{propertyName}} == null)
        {{rootIndent}}{
        {{rootIndent}}    lastValue_{{members[i - 1].DefinedName!}} = true;
        {{rootIndent}}    lastValue_{{propertyName}} = false;
        {{rootIndent}}}
""");
            }
        };
    }

    private void GenerateSerializePropertyPart(
        StringBuilder builder,
        ImmutableArray<TomlValueOnSerializedData> members,
        string rootIndent,
        bool tableStyleHeader,
        bool arrayStyleHeader)
    {
        var memberCount = 0;
        foreach (var member in members)
        {
            memberCount++;
            var indent = member.IsNullable ? $"{rootIndent}    " : $"{rootIndent}";

            // Generate null check if isNullable is true.
            if (member.IsNullable)
            {
                // If NullHandling is Ignore, only check if value is not null
                // Otherwise, also check the global setting
                var condition = member.NullHandling == TomlNullHandling.Ignore
                    ? $"target.{member.DefinedName} != null"
                    : $"target.{member.DefinedName} != null || options.SerializeOptions.DefaultNullHandling == TomlNullHandling.Error";
                builder.AppendLine($$"""
        {{rootIndent}}if ({{condition}})
        {{rootIndent}}{
""");

            }

            switch (member.SerializationKind)
            {
                case TomlSerializationKind.Primitive:
                case TomlSerializationKind.PrimitiveCollection:
                case TomlSerializationKind.Enum:
                case TomlSerializationKind.Struct:
                case TomlSerializationKind.Class:
                case TomlSerializationKind.Interface:
                case TomlSerializationKind.Object:
                    GenerateSerializePrimitivePart(builder, member, indent);
                    break;
                case TomlSerializationKind.TomlSerializedObjectArray:
                case TomlSerializationKind.TomlSerializedObjectCollection:
                    GenerateSerializeTomlSerializedObjectArrayPart(builder, member, indent, arrayStyleHeader);
                    break;
                case TomlSerializationKind.TypeParameter:
                    GenerateSerializeTypeParameterPart(builder, member, indent);
                    break;
                case TomlSerializationKind.NullableStructWithTypeParameter:
                    GenerateSerializeNullableStructWithTypeParameterPart(builder, member, indent);
                    break;
                case TomlSerializationKind.Dictionary:
                    GenerateSerializeDictionaryPart(builder, member, indent, tableStyleHeader);
                    break;
                case TomlSerializationKind.TomlSerializedObject:
                    GenerateSerializeTomlSerializedObjectPart(builder, member, indent, members.Length == 1);
                    break;
                default:
                    GenerateSerializeOtherPart(builder, member, indent);
                    break;
            }

            // Close the null check if block
            if (member.IsNullable)
            {
                builder.AppendLine($$"""
        {{rootIndent}}}
""");
            }
        }
    }

    private void GenerateSerializePrimitivePart(StringBuilder builder, TomlValueOnSerializedData tomlValueOnSerializedData, string indent)
    {
        var propertyName = tomlValueOnSerializedData.DefinedName;
        var accessName = tomlValueOnSerializedData.CanAliasName ? tomlValueOnSerializedData.AliasName : propertyName;
        var fullTypeName = tomlValueOnSerializedData.Symbol.Type.ToFullFormatString();

        builder.AppendLine($$"""
        {{indent}}writer.WriteKey({{$"@\"{accessName}\"u8"}});
        {{indent}}writer.WriteEqual();
        {{indent}}options.Resolver.GetFormatter<{{fullTypeName}}>()!.Serialize(ref writer, target.{{propertyName}}, options);
        {{indent}}writer.EndKeyValue(lastValue_{{propertyName}});
""");
    }

    private void GenerateSerializeTomlSerializedObjectPart(StringBuilder builder, TomlValueOnSerializedData tomlValueOnSerializedData, string indent, bool multiple)
    {
        var propertyName = tomlValueOnSerializedData.DefinedName;
        var accessName = tomlValueOnSerializedData.CanAliasName ? tomlValueOnSerializedData.AliasName : propertyName;
        var symbol = tomlValueOnSerializedData.Symbol;
        var fullTypeName = symbol.Type.ToFullFormatString();

        builder.AppendLine($$"""
        {{indent}}if (options.SerializeOptions.TableStyle == TomlTableStyle.Header && (writer.State == TomlValueState.Default || writer.State == TomlValueState.Table)){
        {{indent}}    writer.WriteTableHeader({{$"@\"{accessName}\"u8"}});
        {{indent}}    writer.WriteNewLine();
        {{indent}}    writer.BeginCurrentState(TomlValueState.Table);
        {{indent}}    writer.PushKey({{$"@\"{accessName}\"u8"}});
        {{indent}}    options.Resolver.GetFormatter<{{fullTypeName}}>()!.Serialize(ref writer, target.{{propertyName}}, options);
        {{indent}}    writer.PopKey();
        {{indent}}    writer.EndCurrentState();
        {{indent}}}
""");
        // Serialize as an array of tables if there are multiple properties
        if (multiple)
        {
            builder.AppendLine($$"""
        {{indent}}else
        {{indent}}{
        {{indent}}    writer.PushKey({{$"@\"{accessName}\"u8"}});
        {{indent}}    options.Resolver.GetFormatter<{{fullTypeName}}>()!.Serialize(ref writer, target.{{propertyName}}, options);
        {{indent}}    writer.PopKey();
        {{indent}}}
""");
        }
        else
        {
            builder.AppendLine($$"""
        {{indent}}else
        {{indent}}{
        {{indent}}    writer.WriteKey({{$"@\"{accessName}\"u8"}});
        {{indent}}    writer.WriteEqual();
        {{indent}}    writer.BeginCurrentState(TomlValueState.ArrayOfTable);
        {{indent}}    options.Resolver.GetFormatter<{{fullTypeName}}>()!.Serialize(ref writer, target.{{propertyName}}, options);
        {{indent}}    writer.EndCurrentState();
        {{indent}}    writer.EndKeyValue(lastValue_{{propertyName}});
        {{indent}}}
""");
        }
    }

    private void GenerateSerializeDictionaryPart(
        StringBuilder builder,
        TomlValueOnSerializedData tomlValueOnSerializedData,
        string indent,
        bool tableStyleHeader)
    {
        var propertyName = tomlValueOnSerializedData.DefinedName;
        var accessName = tomlValueOnSerializedData.CanAliasName ? tomlValueOnSerializedData.AliasName : propertyName;
        var symbol = tomlValueOnSerializedData.Symbol;
        var fullTypeName = symbol.Type.ToFullFormatString();

        var condition = tableStyleHeader ?
            "writer.State == TomlValueState.Default || writer.State == TomlValueState.Table" :
            "options.SerializeOptions.TableStyle == TomlTableStyle.Header && (writer.State == TomlValueState.Default || writer.State == TomlValueState.Table)";

        builder.AppendLine($$"""
        {{indent}}if ({{condition}}){
        {{indent}}    writer.WriteTableHeader({{$"@\"{accessName}\"u8"}});
        {{indent}}    writer.WriteNewLine();
        {{indent}}    writer.BeginCurrentState(TomlValueState.Table);
        {{indent}}    writer.PushKey({{$"@\"{accessName}\"u8"}});
        {{indent}}    options.Resolver.GetFormatter<{{fullTypeName}}>()!.Serialize(ref writer, target.{{propertyName}}, options);
        {{indent}}    writer.PopKey();
        {{indent}}    writer.EndCurrentState();
        {{indent}}}
        {{indent}}else
        {{indent}}{
        {{indent}}    writer.WriteKey({{$"@\"{accessName}\"u8"}});
        {{indent}}    writer.WriteEqual();
        {{indent}}    writer.BeginCurrentState(TomlValueState.ArrayOfTable);
        {{indent}}    options.Resolver.GetFormatter<{{fullTypeName}}>()!.Serialize(ref writer, target.{{propertyName}}, options);
        {{indent}}    writer.EndCurrentState();
        {{indent}}    writer.EndKeyValue(lastValue_{{propertyName}});
        {{indent}}}
""");
    }

    private void GenerateSerializeTomlSerializedObjectArrayPart(
        StringBuilder builder,
        TomlValueOnSerializedData tomlValueOnSerializedData,
        string indent,
        bool arrayStyleHeader)
    {
        var propertyName = tomlValueOnSerializedData.DefinedName;
        var accessName = tomlValueOnSerializedData.CanAliasName ? tomlValueOnSerializedData.AliasName : propertyName;
        var symbol = tomlValueOnSerializedData.Symbol;
        var fullTypeName = symbol.Type.ToFullFormatString();

        var enableArrayOfTable = false;
        if (symbol.Type is IArrayTypeSymbol)
        {
            enableArrayOfTable = true;
        }
        if (symbol.Type is INamedTypeSymbol namedTypeSymbol && namedTypeSymbol.IsGenericType && namedTypeSymbol.TypeArguments.Length == 1)
        {
            // Nullable<T> is a special case.
            var typeSymbol = namedTypeSymbol.ConstructUnboundGenericType();
            if (typeSymbol.ToDisplayString() == "T?")
            {
                var typeArguments = namedTypeSymbol.TypeArguments;
                if (typeArguments[0] is INamedTypeSymbol namedTypeSymbol2 && namedTypeSymbol2.IsGenericType && namedTypeSymbol2.TypeArguments.Length == 1)
                {
                    enableArrayOfTable = true;
                }
            }
            else
            {
                enableArrayOfTable = true;
            }
        }

        if (enableArrayOfTable)
        {
            var arrayStyleCondition = arrayStyleHeader ?
                "" :
                "options.SerializeOptions.ArrayStyle == TomlArrayStyle.Header && ";

            // MEMO: Check null and write empty array when element of array is one. 
            builder.AppendLine($$"""
                    {{indent}}if (!({{arrayStyleCondition}}writer.State != TomlValueState.ArrayOfTableForMulitiLine &&
                    {{indent}}  options.Resolver.GetFormatter<{{fullTypeName}}>()! is ITomlArrayHeaderFormatter<{{fullTypeName}}> _{{propertyName}}HeaderFormatter &&
                    {{indent}}  _{{propertyName}}HeaderFormatter.TrySerialize(ref writer, {{$"@\"{accessName}\"u8"}}, target.{{propertyName}}, options)))
                    {{indent}}{
                    {{indent}}    writer.WriteKey({{$"@\"{accessName}\"u8"}});
                    {{indent}}    writer.WriteEqual();
                    {{indent}}    writer.BeginCurrentState(TomlValueState.ArrayOfTable);
                    {{indent}}    options.Resolver.GetFormatter<{{fullTypeName}}>()!.Serialize(ref writer, target.{{propertyName}}, options);
                    {{indent}}    writer.EndCurrentState();
                    {{indent}}    writer.EndKeyValue(lastValue_{{propertyName}});
                    {{indent}}}
            """);
        }
        else
        {
            builder.AppendLine($$"""
        {{indent}}writer.WriteKey({{$"@\"{accessName}\"u8"}});
        {{indent}}writer.WriteEqual();
        {{indent}}writer.BeginCurrentState(TomlValueState.ArrayOfTable);
        {{indent}}options.Resolver.GetFormatter<{{fullTypeName}}>()!.Serialize(ref writer, target.{{propertyName}}, options);
        {{indent}}writer.EndCurrentState();
        {{indent}}writer.EndKeyValue(lastValue_{{propertyName}});
""");
        }
    }

    private void GenerateSerializeTypeParameterPart(StringBuilder builder, TomlValueOnSerializedData tomlValueOnSerializedData, string indent)
    {
        var propertyName = tomlValueOnSerializedData.DefinedName;
        var accessName = tomlValueOnSerializedData.CanAliasName ? tomlValueOnSerializedData.AliasName : propertyName;
        var symbol = tomlValueOnSerializedData.Symbol;
        var fullTypeName = symbol.Type.ToFullFormatString();

        builder.AppendLine($$"""
        {{indent}}var __{{propertyName}}Formatter = options.Resolver.GetFormatter<{{fullTypeName}}>();
        {{indent}}if (__{{propertyName}}Formatter != null)
        {{indent}}{
        {{indent}}    var __{{propertyName}}__ = target.{{propertyName}};
        {{indent}}    if (__{{propertyName}}__ is ITomlSerializedObject<{{fullTypeName}}>)
        {{indent}}    {
        {{indent}}        if (options.SerializeOptions.TableStyle == TomlTableStyle.Header && (writer.State == TomlValueState.Default || writer.State == TomlValueState.Table))
        {{indent}}        {
        {{indent}}            writer.WriteTableHeader({{$"@\"{accessName}\"u8"}});
        {{indent}}            writer.WriteNewLine();
        {{indent}}            writer.BeginCurrentState(TomlValueState.Table);
        {{indent}}            writer.PushKey({{$"@\"{accessName}\"u8"}});
        {{indent}}            __{{propertyName}}Formatter!.Serialize(ref writer, __{{propertyName}}__, options);
        {{indent}}            writer.PopKey();
        {{indent}}            writer.EndCurrentState();
        {{indent}}        }
        {{indent}}        else
        {{indent}}        {
        {{indent}}            writer.PushKey({{$"@\"{accessName}\"u8"}});
        {{indent}}            __{{propertyName}}Formatter!.Serialize(ref writer, __{{propertyName}}__, options);
        {{indent}}            writer.PopKey();
        {{indent}}        }
        {{indent}}    }
        {{indent}}    else
        {{indent}}    {
        {{indent}}        writer.WriteKey({{$"@\"{accessName}\"u8"}});
        {{indent}}        writer.WriteEqual();
        {{indent}}        writer.BeginCurrentState(TomlValueState.ArrayOfTable);
        {{indent}}        __{{propertyName}}Formatter!.Serialize(ref writer, __{{propertyName}}__, options);
        {{indent}}        writer.EndCurrentState();
        {{indent}}        writer.EndKeyValue(lastValue_{{propertyName}});
        {{indent}}    }
        {{indent}}}
""");
    }

    private void GenerateSerializeNullableStructWithTypeParameterPart(StringBuilder builder, TomlValueOnSerializedData tomlValueOnSerializedData, string indent)
    {
        var propertyName = tomlValueOnSerializedData.DefinedName;
        var accessName = tomlValueOnSerializedData.CanAliasName ? tomlValueOnSerializedData.AliasName : propertyName;
        var symbol = tomlValueOnSerializedData.Symbol;

        if (symbol.Type is not INamedTypeSymbol namedType) return;

        var namedTypeName = namedType.ToFullFormatString();

        builder.AppendLine($$"""
        {{indent}}var __{{propertyName}}Formatter = options.Resolver.GetFormatter<{{namedTypeName}}>();
        {{indent}}if (__{{propertyName}}Formatter != null)
        {{indent}}{
        {{indent}}    var __{{propertyName}}__ = target.{{propertyName}};
        {{indent}}    if (__{{propertyName}}__ is ITomlSerializedObject<{{namedType.TypeArguments[0].ToFullFormatString()}}>)
        {{indent}}    {
        {{indent}}        if (options.SerializeOptions.TableStyle == TomlTableStyle.Header && (writer.State == TomlValueState.Default || writer.State == TomlValueState.Table))
        {{indent}}        {
        {{indent}}            writer.WriteTableHeader({{$"@\"{accessName}\"u8"}});
        {{indent}}            writer.WriteNewLine();
        {{indent}}            writer.BeginCurrentState(TomlValueState.Table);
        {{indent}}            writer.PushKey({{$"@\"{accessName}\"u8"}});
        {{indent}}            __{{propertyName}}Formatter!.Serialize(ref writer, __{{propertyName}}__, options);
        {{indent}}            writer.PopKey();
        {{indent}}            writer.EndCurrentState();
        {{indent}}        }
        {{indent}}        else
        {{indent}}        {
        {{indent}}            writer.PushKey({{$"@\"{accessName}\"u8"}});
        {{indent}}            __{{propertyName}}Formatter!.Serialize(ref writer, __{{propertyName}}__, options);
        {{indent}}            writer.PopKey();
        {{indent}}        }
        {{indent}}    }
        {{indent}}    else
        {{indent}}    {
        {{indent}}        writer.WriteKey({{$"@\"{accessName}\"u8"}});
        {{indent}}        writer.WriteEqual();
        {{indent}}        writer.BeginCurrentState(TomlValueState.ArrayOfTable);
        {{indent}}        __{{propertyName}}Formatter!.Serialize(ref writer, __{{propertyName}}__, options);
        {{indent}}        writer.EndCurrentState();
        {{indent}}        writer.EndKeyValue(lastValue_{{propertyName}});
        {{indent}}    }
        {{indent}}}
""");
    }

    private void GenerateSerializeOtherPart(StringBuilder builder, TomlValueOnSerializedData tomlValueOnSerializedData, string indent)
    {
        var propertyName = tomlValueOnSerializedData.DefinedName;
        var accessName = tomlValueOnSerializedData.CanAliasName ? tomlValueOnSerializedData.AliasName : propertyName;
        var fullTypeName = tomlValueOnSerializedData.Symbol.Type.ToFullFormatString();

        builder.AppendLine($$"""
        {{indent}}writer.WriteKey({{$"@\"{accessName}\"u8"}});
        {{indent}}writer.WriteEqual();
        {{indent}}options.Resolver.GetFormatter<{{fullTypeName}}>()!.Serialize(ref writer, target.{{propertyName}}, options);
        {{indent}}writer.EndKeyValue(lastValue_{{propertyName}});
""");
    }

    private string GenerateRegisterPart(TypeMeta typeMeta)
    {
        var builder = new StringBuilder();
        foreach (var (type, kind) in typeMeta.DefinedTypes)
        {
            var fullTypeName = type.ToFullFormatString();
            switch (kind)
            {
                case TomlSerializationKind.Primitive:
                case TomlSerializationKind.PrimitiveArray:
                    continue;
                case TomlSerializationKind.Enum:
                    builder.AppendLine($$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{fullTypeName}}>())
        {
            TomlValueFormatterResolver.Register(new EnumFormatter<{{fullTypeName}}>());
        }
""");
                    break;
                case TomlSerializationKind.TomlSerializedObject:
                    builder.AppendLine($$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{fullTypeName}}>())
        {
            TomlValueFormatterResolver.Register<{{fullTypeName}}>();
        }
""");
                    continue;
                case TomlSerializationKind.TomlSerializedObjectArray:
                    var arrayNamedType = (IArrayTypeSymbol)type;
                    var elementType = arrayNamedType.ElementType;

                    builder.AppendLine($$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{fullTypeName}}>())
        {
            TomlValueFormatterResolver.Register(new ArrayFormatter<{{elementType.ToFullFormatString()}}>());
        }
""");
                    break;
                case TomlSerializationKind.TomlSerializedObjectCollection:
                    if (type is INamedTypeSymbol namedTypeSymbol && namedTypeSymbol.IsGenericType)
                    {
                        // Nullable<T> is a special case.
                        var typeSymbol = namedTypeSymbol.ConstructUnboundGenericType();
                        if (typeSymbol.ToDisplayString() == "T?")
                        {
                            builder.AppendLine($$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{fullTypeName}}>())
        {
            TomlValueFormatterResolver.Register(new NullableFormatter<{{namedTypeSymbol.TypeArguments[0].ToFullFormatString()}}>());
        }
""");
                            break;
                        }

                        if (FormatterTypeMetaData.TryGetGenericFormatterType(typeSymbol.ToFullFormatString(), out var typeFormatter) != GenericFormatterType.None)
                        {
                            var typeParameters = string.Join(",", namedTypeSymbol.TypeArguments.Select(x => x.ToFullFormatString()));
                            typeFormatter = typeFormatter.Replace("TYPEPARAMETER", typeParameters);

                            builder.AppendLine($$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{fullTypeName}}>())
        {
            TomlValueFormatterResolver.Register(new {{typeFormatter}}());
        }
""");
                            break;
                        }
                    }
                    else
                    {
                        if (FormatterTypeMetaData.TryGetGenericFormatterType(type, out var formatter) != GenericFormatterType.None)
                        {
                            var collectionNamedType = (INamedTypeSymbol)type;
                            var typeParameters = string.Join(",", collectionNamedType.TypeArguments.Select(x => x.ToFullFormatString()));
                            formatter = formatter!.Replace("TYPEPARAMETER", typeParameters);

                            builder.AppendLine($$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{fullTypeName}}>())
        {
            TomlValueFormatterResolver.Register(new {{formatter}}());
        }
""");
                        }
                    }

                    break;
                case TomlSerializationKind.Dictionary:
                    if (FormatterTypeMetaData.TryGetGenericFormatterType(type, out var dictFormatter) != GenericFormatterType.None)
                    {
                        var dictNamedType = (INamedTypeSymbol)type;
                        var typeParameters = string.Join(",", dictNamedType.TypeArguments.Select(x => x.ToFullFormatString()));
                        dictFormatter = dictFormatter!.Replace("TYPEPARAMETER", typeParameters);

                        builder.AppendLine($$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{fullTypeName}}>())
        {
            TomlValueFormatterResolver.Register(new {{dictFormatter}}());
        }
""");
                    }
                    break;
                case TomlSerializationKind.NullableStructWithTypeParameter:
                    if (type is not INamedTypeSymbol namedType) break;

                    var namedTypeName = namedType.ToFullFormatString();
                    builder.AppendLine($$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{namedTypeName}}>())
        {
            TomlValueFormatterResolver.Register(new NullableFormatter<{{namedType.TypeArguments[0].ToFullFormatString()}}>());
        }
""");

                    break;
                default:
                    if (FormatterTypeMetaData.ContainsBuiltInFormatterType(type))
                        break;

                    if (type is INamedTypeSymbol namedTypeSymbol2 && namedTypeSymbol2.IsGenericType)
                    {
                        // Nullable<T> is a special case.
                        var typeSymbol = namedTypeSymbol2.ConstructUnboundGenericType();
                        if (typeSymbol.ToDisplayString() == "T?")
                        {
                            builder.AppendLine($$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{fullTypeName}}>())
        {
            TomlValueFormatterResolver.Register(new NullableFormatter<{{namedTypeSymbol2.TypeArguments[0].ToFullFormatString()}}>());
        }
""");
                            break;
                        }

                        if (FormatterTypeMetaData.TryGetGenericFormatterType(typeSymbol.ToFullFormatString(), out var typeFormatter) != GenericFormatterType.None)
                        {
                            var typeParameters = string.Join(",", namedTypeSymbol2.TypeArguments.Select(x => x.ToFullFormatString()));
                            typeFormatter = typeFormatter.Replace("TYPEPARAMETER", typeParameters);

                            builder.AppendLine($$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{fullTypeName}}>())
        {
            TomlValueFormatterResolver.Register(new {{typeFormatter}}());
        }
""");
                            break;
                        }
                    }
                    break;
            }
        }

        if (typeMeta.IsReferenceType)
        {
            var code = $$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{typeMeta.TypeName}}>())
        {
            TomlValueFormatterResolver.Register(new TomlSerializedObjectFormatter<{{typeMeta.TypeName}}>());
        }

        // Register Formatter in advance.
{{builder}}
""";
            return code;
        }
        else
        {
            var code = $$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{typeMeta.TypeName}}>())
        {
            TomlValueFormatterResolver.Register(new StructTomlSerializedObjectFormatter<{{typeMeta.TypeName}}>());
        }

        // Register Formatter in advance.
{{builder}}
""";
            return code;
        }
    }
}

internal class Comparer : IEqualityComparer<(GeneratorAttributeSyntaxContext, Compilation)>
{
    public static readonly Comparer Instance = new();

    public bool Equals((GeneratorAttributeSyntaxContext, Compilation) x, (GeneratorAttributeSyntaxContext, Compilation) y)
    {
        return x.Item1.TargetNode.Equals(y.Item1.TargetNode);
    }

    public int GetHashCode((GeneratorAttributeSyntaxContext, Compilation) obj)
    {
        return obj.Item1.TargetNode.GetHashCode();
    }
}
